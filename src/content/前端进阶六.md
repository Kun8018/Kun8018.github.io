---
title: 前端进阶（六）
date: 2020-12-13 21:40:33
categories: Web
tags:
    - Web
toc: true
thumbnail: http://cdn.kunkunzhang.top/jenkins.png
---

　　前端进阶六，web api

<!--more-->

## 内网穿透

内网穿透，即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透。就是说映射端口，能让外网的电脑找到处于内网的电脑，提高下载速度。不管是内网穿透还是其他类型的网络穿透，都是网络穿透的统一方法来研究和解决。

内网穿透的应用场景：

- 内网穿透，可代替vpn
- 将无外网IP的desktop映射到公网
- 临时搭建网络并分配二级域名
- 微信二次开发的本地调试

方法1:localtunnel （使用国外网，非常慢，经常超时，不建议使用）

首先安装包

```shell
npm install -g localtunnel
```

在本地开启服务后，如服务在8080端口，运行命令开启服务

```shell
lt --subdomain mitu --port 8080
```

lt为localtunnel的缩写，mitu是指定域名前缀为mitu，8080为配置端口

常见错误：

（1）运行脚本命令错误：以管理员模式开启脚本权限

（2）invalid host header：在webpack的配置devServer下添加配置：disableHostCheck: true

方法二：natapp （国内网站）

方法三：ngrok

ngrok需要在服务端和客户端配置，客户端叫ngrokd，服务端叫ngrok



https://juejin.cn/post/6844903623659356168

https://aotu.io/notes/2016/02/19/ngrok/index.html

https://xicheng412.github.io/2016/09/27/ngrok-config/



## Iconfont的使用

iconfont有三种使用方式：

unicode

```html
<span class="icon-font">&#59173</span>
```

font class

```html
<span class="iconfont icon-2018-pc"></span>
```

Symbol

```html
<svg class="icon" aria-hidden="true">	<use xlink:href="#icon-2018-tu"></use></svg>
```

前两种不支持彩色图标，第三种支持



## 业务场景代码

### 手写轮播图

轮播需要设置一个很长的DOM，设置超出容器隐藏，使用setInterval进行轮播，计算便宜位置。

DOM左端与右端交换的时候会有快速滑动，为了体验好一点，我会设置两层DOM，在容器之外的DOM进行DOM的左右交换。

```javascript
const position = [-8,-388,-768,-1148,-1528,-1908,-2208,-2668,-3048,-3428]var certificate = document.getElementById("certificate-inner");var i = 3;function pre_pic(){   if(i >= 1){     if(isNaN(parseInt(certificate.style.marginLeft)) || parseInt(certificate.style.marginLeft) < -400)         i--;         var newLeft = position[i] + "px";         $("#certificate-inner").animate({marginLeft:newLeft},500);     else if (parseInt(certificate.style.marginLeft)> -400 || i >= 1){         i++;         var newLeft = position[i] + "px";         $("#certificate-inner").animate({marginLeft:newLeft},500);         setTimeout(function(){            i = 6;            certificate.style.marginLeft = "-2283px"         },3985)     }   }else{     i = 5;     certificate.style.marginLeft = "-2283px";     var newLeft = position[i] + "px"     $("#certificate-inner").animate({marginLeft:newLeft},500);   }}function next_pic(){   if(i < 9){     if(isNaN(parseInt(certificate.style.marginLeft))|| parseInt(certificate.style.marginLeft) > 374*8 || i > 0)			{        i++;        var newLeft = position[i] + "px"        $("#certificate-inner").animate({marginLeft:newLeft},500)     }     else{        i++;        var newLeft = position[i] + "px"        $("#certificate-inner").animate({marginLeft:newLeft},500)        setTimeout(function(){          i = 3;          certificate.style.marginLeft = "-1143px"        },3985)     }     newLeft = newLeft + "px"     time = 0;   }else{     i = 4;     certificate.style.marginLeft = "1143px";     var newLeft = position[i] + "px"     $("#certificate-inner").animate({marginLeft:newLeft},500)   }}$(".left-coursol-icon").on("click",function(e){  e.preventDefault();  pre_pic();})$(".right-coursol-icon").on("click",function(e){  e.preventDefault();  next_pic();})var time = null;function autoplay(){  time = setInterval(function(){    next_pic();  },4000);}autoplay();
```



### 手写图片懒加载



### 手写Google搜索



### 前端添加水印



## 前端大容量缓存方案indexedDB

对于做3D WebGL 的开发者来说，加载大量的 hdr、glb、gltf 等文件往往是很令人头疼的，因为这些文件体积不小，在网络侧加载会消耗大量时间，从而影响用户体验。对于这些大文件，localstorage 和 sessionstorage 的缓存容量肯定是不够塞牙缝的。所以这时候我们要请出 IndexedDB。

IndexedDB 是一种可以让你在用户的浏览器内持久化存储数据的方法， 允许储存大量数据，提供查找接口，还能建立索引。 IndexedDB 的兼容性也还不错，基本上不兼容太老的浏览器，都还是可用的。

容量

chrome67设置了should remain available，这个值表示为浏览器本身需要留出来的空间，硬盘容量除去这个值以后的空间就是浏览器临时存储可用空间

大文件存储

IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象），所以我们可以把图片或者 3D 模型文件转化成 Blob 格式的文件，存在 IndexedDB 中，就可以解决免去二次加载时网络请求的时间。

IndexedDB 完全可以满足存储大体积文件的需求，并且 IndexedDB 可以 worker 中使用，包括 Web Worker 和 Service Worker，当 3D 需要进行复杂计算时，就可以利用 Service Worker 把一些数据存储在 IndexedDB 中或者通过 Web Worker 读取 IndexedDB 中的数据进行多线程计算。

需要注意的是 IndexedDB 也遵从同源协议([same-origin policy](http://www.w3.org/Security/wiki/Same_Origin_Policy))，所以你只能访问同域中存储的数据，而不能访问其他域的。

## 

## 前端监控

### 性能监控-关键指标

首屏时间：从浏览器输入地址并回车后到首屏内容渲染完毕的时间；首屏时间等于白屏时间+首屏渲染时间

白屏时间：是指从用户进入网站（输入url、刷新、跳转等方式）的时刻开始计算，一直到页面有内容展示出来的时间节点。这个过程包括dns查询、建立tcp连接、发送首个http请求（如果使用https还要介入TLS的验证时间）、返回html文档、html文档head解析完毕。

用户可操作时间节点：domready触发节点，点击事件有反应；

总下载时间：window.onload的触发节点。

### window.performance

Window.performance是用来测量网页和Web应用程序的性能api，performance中有以下字段用来衡量性能：

`memory字段`代表JavaScript对内存的占用。

`navigation字段`统计的是一些网页导航相关的数据：redirectCount:重定向的数量（只读），但是这个接口有同源策略限制，即仅能检测同源的重定向；type 返回值应该是0,1,2 中的一个。分别对应三个枚举值: 0 : TYPE_NAVIGATE (用户通过常规导航方式访问页面，比如点一个链接，或者一般的get方式) 1 : TYPE_RELOAD (用户通过刷新，包括JS调用刷新接口等方式访问页面) 2 : TYPE_BACK_FORWARD (用户通过后退按钮访问本页面)

`timing字段`的统计数据，它包含了网络、解析等一系列的时间数据。具体包括：

DNS查询耗时 ：`domainLookupStart`和`domainLookupEnd`分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart；

TCP链接耗时：`connectStart`和`connectEnd`分别代表TCP建立连接和连接成功的时间节点。如果浏览器没有进行TCP连接（比如使用持久化连接webscoket），则两者都等于domainLookupEnd；

request请求耗时：`responseStart`和`responseEnd`分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻；

解析dom树耗时:`domComplete`html文档完全解析完毕的时间节点减去`domInteractive`，代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点；

白屏时间：`domLoading`代表浏览器开始解析html文档的时间节点减去`fetchStart`是指在浏览器发起任何请求之前的时间值。

domready可操作时间 ：domContentLoadedEventEnd 代表DOMContentLoaded事件完成的时间节点，此刻用户可以对页面进行操作，也就是jQuery中的domready时间；- fetchStart

onload总下载时间 = loadEventEnd代表onload事件结束的时间节点-fetchStart；

### 实例方法

白屏时间

在html文档的head中所有的静态资源以及内嵌脚本/样式之前记录一个时间点，在head最底部记录另一个时间点，两者的差值作为白屏时间

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>白屏时间</title>    <script>        // 开始时间        window.pageStartTime = Date.now();    </script>    <link rel="stylesheet" href="">    <link rel="stylesheet" href="">    <script>        // 白屏结束时间        window.firstPaint = Date.now()    </script></head><body>    <div>123</div></body></html>白屏时间 = firstPaint - pageStartTime
```

通常计算首屏的方法有

- 首屏模块标签标记法
- 统计首屏内加载最慢的图片的时间
- 自定义首屏内容计算法 

标签标记法

由于浏览器解析HTML是按照顺序解析的，当解析到某个元素的时候，觉得首屏完成了，就在此元素后面加入<script>计算首屏完成时间

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>首屏时间</title>    <script>        // 开始时间        window.pageStartTime = Date.now();    </script>    <link rel="stylesheet" href="">    <link rel="stylesheet" href=""></head><body>    <div>123</div>    <div>456</div>    // 首屏可见内容    <script>        // 首屏结束时间        window.firstPaint = Date.now();    </script>    // 首屏不可见内容    <div class=" "></div></body></html>首屏时间 = firstPaint - pageStartTime
```

**统计首屏内加载最慢的图片/iframe**（更常用）

```html
<!DOCTYPE html><html><head>    <meta charset="UTF-8">    <title>首屏时间</title>    <script>        window.pageStartTime = Date.now()    </script></head><body>    <img src="https://lz5z.com/assets/img/google_atf.png" alt="img" onload="load()">    <img src="https://lz5z.com/assets/img/css3_gpu_speedup.png" alt="img" onload="load()">    <script>        function load () {            window.firstScreen = Date.now()        }        window.onload = function () {            // 首屏时间            console.log(window.firstScreen - window.pageStartTime)        }    </script></body></html>
```

缺点：使用场景受限

同样无法获取解析html文档之前的时间信息

这种方案比较适合首屏元素数量固定的页面，比如移动端首屏不论屏幕大小都展示相同数量的内容，响应式得改变内容的字体、尺寸等。

但是对于首屏元素不固定的页面，这种方案并不适用，最典型的就是PC端页面，不同屏幕尺寸下展示的首屏内容不同。上述方案便不适用于此场景。

可操作时间

用户可操作的时间节点即dom ready触发的时间，使用jquery可以通过$(document).ready()获取此数据。

```javascript
// 原生JS实现dom readywindow.addEventListener('DOMContentLoaded', (event) => {    console.log('DOM fully loaded and parsed');});
```

总下载时间

总下载时间即window.onload触发的时间节点。



### lightHouse

Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。只要为 Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。

目前官方提供了四种使用lighthouse的方式：

chrome开发者工具

chrome扩展

Node CLI

Node Module

以 Chrome 开发者工具为例，在 Audits 面板下，用户可以配置测试平台、测试类目、限速方式等，可以方便快捷地发起一次测试。

测试结束后，默认会生成 HTML 格式的报告，如下图所示，在报告中涵盖了 5 大类别（categories）的测试评分

每个类别都包含一系列的审计项（audit），针对审计项的运行结果，Lighthouse 会给出特定的优化建议与诊断结果帮助开发者有针对性地进行优化。

Node CLi

安装cli工具

```shell
npm install -g lighthouse
```

进行测试

```shell
lighthouse --only-categories=performance https://google.com
```

Node lightHouse测试流程

1. Lighthouse 与浏览器建立连接。

2. 测试的初始化配置与加载待测试页面。

3. 在页面加载过程中，运行一系列的采集器（gatherers），每个采集器都会收集自己的目标信息，并生成中间产物（artifacts）。

4. 运行一系列的审计项（audits），每个审计项都会从中间产物（artifacts）中获取所需的数据，计算出各自的评分。

5. 基于审计项的评分计算出大类的评分，汇总生成报告。

#### 报告

整体质量评估主要有5个方面：性能（Performance）、可访问性（Accessibility）、网络最佳实践（Best Practies）、搜索引擎优化（SEO）渐进式应用PWA（Progressive Web Apps）

性能评估主要包含6大指标：

1. 首次有内容绘制时间（**FCP**，First Contentful Paint）：用于记录页面首次绘制文本、图片、非空白 Canvas 或 SVG 的时间。
2. 最大内容绘制时间（**LCP**，Largest Contentful Paint）：用于记录视窗内最大的元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指标会在用户第一次交互后停止记录。
3. 速度指数（Speed Index）: 指的是网页以多快的速度展示内容，标准时间是**4s**。
4. 阻塞交互时间（**TBT**, Total Blocking Time）：用户体验指标，代表着页面何时真正进入可用的状态。毕竟光内容渲染的快也不够，还要能迅速响应用户的交互。
5. 用户可交互时间（**TTI**, Time to Interactive）：这个指标并不是指的最早的可交互时间，而是可流畅交互的时间，具体的值为FMP之后，5秒后没有long task执行（50ms以上的任务）的时间
6. 累计布局偏移（**CLS**, Cumulative Layout Shift）：记录了页面上非预期的位移波动。

### web-vital

“网页指标”计划是 Google 推出的一项计划，旨在就哪些质量信号对提供出色的网站用户体验至关重要提供统一指南。

多年来，Google 提供了许多用于衡量和报告效果的工具。有些开发者擅长使用这些工具，而有些开发者则发现，由于工具和指标众多，很难跟上节奏。

网站所有者不必是效果专家，也能了解自己为用户提供的体验质量。Web Vitals 计划旨在简化环境，帮助网站专注于最重要的指标，即 **Core Web Vitals**。

核心网页指标是适用于所有网页的一部分网页指标，所有网站所有者都应衡量这些指标，并且这些指标将显示在所有 Google 工具中。核心网页指标中的每个指标分别代表着用户体验的不同方面，可在[实际环境中](https://web.dev/articles/user-centric-performance-metrics?hl=zh-cn#how_metrics_are_measured)衡量，并反映了[以用户为中心](https://web.dev/articles/user-centric-performance-metrics?hl=zh-cn#how_metrics_are_measured)的关键结果的真实体验。

构成 Core Web Vitals 的指标会随着时间的推移而[演变](https://web.dev/articles/vitals?hl=zh-cn#evolving-web-vitals)。当前这组指标侧重于用户体验的三个方面：*加载速度*、*互动性*和*视觉稳定性*，其中包括以下指标（及其各自的阈值）

- **[Largest Contentful Paint (LCP)](https://web.dev/articles/lcp?hl=zh-cn)**：衡量*加载*性能。为了提供良好的用户体验，应在网页首次开始加载的 **2.5 秒**内完成 LCP。
- **[Interaction to Next Paint (INP)](https://web.dev/articles/inp?hl=zh-cn)**：衡量*互动性*。为了提供良好的用户体验，网页的 INP 应不超过 **200 毫秒**。
- **[Cumulative Layout Shift (CLS)](https://web.dev/articles/cls?hl=zh-cn)**：衡量*视觉稳定性*。为了提供良好的用户体验，网页的 CLS 应保持在 **0.1** 或更低。

为确保大多数用户都能达到这些指标的建议目标值，一个合适的衡量阈值是网页加载时间的**第 75 个百分位数**，并按移动设备和桌面设备进行细分。



### webfunny

Webfunny是一款集前端监控和埋点于一体的大数据分析系统。监控系统主要帮助开发者、测试工程师排查和解决线上的疑难杂症问题；埋点系统主要用于帮助分析师、产品经理分析业务数据，提高企业转化率。一个面向技术、一个面向业务，两者配合使用，效果最好。

一键部署

监控系统和埋点系统都属于大数据系统的范畴，如果把一套完整的大数据系统运行起来，需要多方的技术配合。Webfunny根据自身的特点，采用了较少的技术栈和极简的部署模式，将多套系统的采集、存储、分析和可视化整合在一个平台上运行，仅需要一个NodeJs环境，就可以运行起来了。

 真正做到一键式，部署和维护成本大大降低，方便快捷。

 支持 **代码部署**、**Docker容器化部署**。

https://www.webfunny.com/des?desPath=guide/des

### web-see

https://github.com/xy-sea/web-see

前端监控SDK，可用来收集并上报：代码报错、性能数据、页面录屏、用户行为、白屏检测等个性化指标数据

亮点1：支持多种错误还原方式：定位源码、播放录屏、记录用户行为

亮点2：支持项目的白屏检测，兼容有骨架屏、无骨架屏这两种情况

亮点3：支持错误上报去重，错误生成唯一的id，重复的代码错误只上报一次

亮点4：支持多种上报方式，默认使用web beacon，也支持图片打点、http 上报

功能：

- [√] ✈️ 错误捕获：代码报错、资源加载报错、接口请求报错
- [√] ✈️ 性能数据：FP、FCP、LCP、CLS、TTFB、FID
- [√] ✈️ 用户行为：页面点击、路由跳转、接口调用、资源加载
- [√] ✈️ 个性化指标：Long Task、Memory 页面内存、首屏加载时间
- [√] ✈️ 白屏检测：检测页面打开后是否一直白屏
- [√] ✈️ 错误去重：开启缓存队列，存储报错信息，重复的错误只上报一次
- [√] 🚀 手动上报错误
- [√] 🚀 支持多种配置：自定义 hook 与选项
- [√] 🚀 支持的 Web 框架：vue2、vue3、React

```shell
// 安装核心模块
$ npm i @websee/core

// 安装性能检测插件
$ npm i @websee/performance

// 安装页面录屏插件
$ npm i @websee/recordscreen
```





### 前端白屏检测SDK设计与实现

 前端白屏指页面在加载过程中长时间无法正常展示内容，内容区空白，使用户无法进行查看、保存等一切操作，这是非常严重的问题。如果能尽早检测到白屏问题，就可以及时处理，避免或降低负面影响。白屏的检测手段有两种。一是真实用户端的检测，通过接入白屏检测 SDK 实现，无法在用户端白屏报错前发现问题，是被动监控的方式；另一种是自动化检测，在团队内部通过自动化工具模拟用户行为主动检测，可以提前发现问题。

白屏的通常表现为:

- 页面空白或仅显示背景色，没有实际内容。
- 页面一直展示骨架屏，包括页面 loading 状态。
- 页面只展示导航菜单，内容区空白，包括微前端或 iframe 嵌套子页面的场景。

| 检测根节点是否渲染                    | SPA框架渲染的 DOM 一般挂载在一个根节点下，监听onload、onerror事件，检测根节点下是否挂载 DOM | 开发成本低                     | 通用性差，只兼容主流 SPA 框架                                |
| ------------------------------------- | ------------------------------------------------------------ | ------------------------------ | ------------------------------------------------------------ |
| 监听 DOM 变化                         | 利用 Mutation Observer API 监听DOM变化                       | 开发成本低                     | 准确度低，无法检测未渲染、始终渲染骨架屏等情况，如果用户长时间未操作DOM可能会误判白屏 |
| 页面截图对比                          | 对页面截图，将截图与纯白的图片做对比                         | 技术栈无关，通用性好           | 准确度低，无法检测纯背景色、骨架屏的白屏场景                 |
| 前端框架内置ErrorBoundary组件捕获异常 | 利用ErrorBoundary组件捕获JS执行异常检测白屏                  | 开发成本低                     | 无法检测资源异常导致的白屏，只兼容于特定框架应用，接入时对业务代码侵入大 |
| 页面关键点采样对比                    | 在页面中垂直/交叉取多个采样点，用 elementsFromPoint API 获取采样点下的 HTML 元素，判断采样点元素是否与容器元素相同 | 准确度高，技术栈无关，通用性好 | 开发成本稍高                                                 |

elementsFromPoint(x, y) 方法返回指定坐标（相对于视口）处的所有元素的数组。元素从视口的最顶部到最底部的盒模型排序。

数据采集

采样点的选取有三种方式：垂直采样、交叉采样、垂直交叉采样。采样点越多判断越准确，但计算量稍大一点，不过我们利用 requestIdleCallback 在浏览器空闲时计算，因此，我们选择垂直交叉的采样方式。

有骨架屏和无骨架屏应用的检测方式不一样，检测时机也有细微差别。

无骨架屏的场景

**检测时机**

- document.readyState 在 complete 时或 load 事件触发时。
- 全局 error 事件触发时。
- 全局 unhandledrejection 事件触发时。

**2. 检测方式**

- 初始化 SDK 时，我们需要配置哪些是根容器，如果根容器为空则说明是白屏。
- 具体实现方式为，根据屏幕的宽度（window.innerWidth）和高度（window.innerHeight）算出每个采样点的具体坐标，再用 elementsFromPoint 获取每个坐标的 dom 元素，对比获取的元素是否为配置的根容器元素。

**有骨架屏场景**

**1. 检测时机**

- document.readyState在complete 之前。
- 全局 error 事件触发时。
- 全局 unhandledrejection 事件触发时。

**2. 检测方式**

如果应用内有骨架屏，继续用无骨架屏应用的白屏检测方式已经无法判断白屏，因为骨架屏也是有效的 dom 元素。

有骨架屏应用的检测方式为：对比初次采样前后获取的 dom 元素是否一致。因为在页面加载完成前可能已经渲染完骨架屏，为了获取对照组数据，初次采样的时间要在页面加载完成前。

检测出白屏问题后，就要上报白屏信息到数据后台了。一般数据后台需要有数据清洗、存储、消费、告警等功能。此外，还需要区分不同的产品与环境，控制上报数据并发量、上报用户浏览器信息、用户行为数据、方便排查问题的 Sourcemap，告警方式与规则等细节问题。如果要将数据后台做得全面细致，实现成本是比较高的。

因为目前我们在使用的云音乐部门同事研发的前端错误监控平台 Corona，可以满足我们的需求，因此我们将 Corona 作为了白屏检测上报的数据后台。我们要做的就是将上报白屏错误到 Corona 的逻辑，内置到白屏检测 SDK 中

白屏检测 SDK 支持以外链方式接入前端 Web 应用，除业务方使用的监控后台脚本外（如云音乐的 Corona SDK），不依赖其他资源加载，一般只需要改动模板文件，不侵入业务代码。

注意，不建议通过 npm 包的方式接入白屏检测 SDK，因为这种方式在入口资源加载后才会初始化 SDK，无法检测到入口资源加载异常导致的白屏

https://mp.weixin.qq.com/s/JcesgOWwvwrmS5JxgVjEAw

## 前端调试工具

### whistle

[whistle](https://github.com/avwo/whistle)(读音[ˈwɪsəl]，拼音[wēisǒu])基于Node实现的跨平台web调试代理工具，类似的工具有Windows平台上的[Fiddler](http://www.telerik.com/fiddler/)，主要用于查看、修改HTTP、HTTPS、Websocket的请求、响应，也可以作为HTTP代理服务器使用，不同于Fiddler通过断点修改请求响应的方式，whistle采用的是类似配置系统hosts的方式，一切操作都可以通过配置实现，支持域名、路径、正则表达式、通配符、通配路径等多种[匹配方式](https://wproxy.org/whistle/pattern.html)，且可以通过Node模块[扩展功能](https://wproxy.org/whistle/plugins.html)：

whistle的所有操作都可以通过类似如下配置方式实现
```
pattern operatorURI
```

**pattern** 为匹配请求url的表达式，可以为：域名，路径，正则及通配符等等多种匹配方式：

```shell
 # 域名匹配
 www.example.com
 # 带端口的域名
 www.example.com:6666
 # 带协议的域名，支持：http、https、ws、wss、tunnel
 http://www.example.com

 # 路径匹配，同样支持带协议、端口
 www.example.com/test
 https:/www.exapmle.com/test
 https:/www.exapmle.com:6666/test

 # 正则匹配
 /^https?://www\.example\.com\/test/(.*)/ referer://http://www.test.com/$1

 # 通配符匹配
 ^www.example.com/test/*** referer://http://www.test.com/$1
```

**operatorURI** 为对应的操作，由操作协议+操作值组成(`operatorURI = opProtocol://opValue`)：

**opProtocol**(操作协议)， 对应某类操作，如：

```shell
# 设置请求服务器IP--host
pattern host://opValue

# 本地替换--file协议
pattern file://opValue
```

**opValue**(操作值)， 对应具体操作的参数值，如

```shell
# 设置请求服务器IP--host协议
pattern host://127.0.0.1:6666 # 或 pattern 127.0.0.1:6666

# 本地替换--file协议
pattern file:///User/test/dirOrFile # 或 pattern /User/test/dirOrFile
pattern file://E:\test\dirOrFile # 或 pattern E:\test\dirOrFile
```

https://wproxy.org/whistle/install.html



### Charles



#### npm包

charles-mock-server





## 前端测试

现如今大部分互联网团队都是走 **敏捷开发** 的节奏。实际上，自动化测试才是实现“敏捷”的基本保障。业务端的快速上线和快速验证对技术侧的响应力提出了更高的要求：**更快上线，持续上线**。再考虑到人员流动和应用逐步变大的事实，日后迭代的成本只会变得越来越高。当然这个项目迭代的成本也跟项目的复杂度有关，比如笔者所在的点餐业务，项目有足够的复杂性，有些细微的改动点其实会牵扯到很多内容，而对刚加入团队的新人就会显得不太友好。因此，项目拥有前端测试是必不可少的，它能够有效保障业务迭代的质量和稳定性。

我们经常说的单元测试其实只是前端测试的一种。前端测试分为单元测试，UI 测试，集成测试和端到端测试。

- 单元测试：是指对软件中的最小可测试单元进行检查和验证，通常指的是独立测试单个函数。
- UI 测试：是对图形交互界面的测试。
- 集成测试：就是测试应用中不同模块如何集成，如何一起工作，这和它的名字一致。
- 端到端测试（e2e）：是站在用户角度的测试，把我们的程序看成是一个黑盒子，我不懂你内部是怎么实现的，我只负责打开浏览器，把测试内容在页面上输入一遍，看是不是我想要得到的结果。

前端测试的框架可谓是百花齐放。

- 单元测试有 Mocha, Ava, Karma, Jest, Jasmine 等。
- UI 测试有 ReactTestUtils, Test Render, Enzyme, React-Testing-Library, Vue-Test-Utils 等。
- e2e 测试有 Nightwatch, Cypress, Phantomjs, Puppeteer 等。

单元测试

https://kerminate.me/2019/12/22/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/#more







## chrome插件开发

Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个[.crx](https://developer.chrome.com/extensions/crx)后缀的压缩包.

个人猜测`crx`可能是`Chrome Extension`如下3个字母的简写

另外，其实不只是前端技术，Chrome插件还可以配合C++编写的dll动态链接库实现一些更底层的功能(NPAPI)，比如全屏幕截图。

chrome插件能够增强浏览器功能，轻松实现属于自己的“定制版”浏览器，等等。

Chrome插件提供了很多实用API供我们使用，包括但不限于：书签控制；下载控制；窗口控制；标签控制；网络请求控制，各类事件监听；自定义原生菜单；完善的通信机制等等；

为什么是Chrome插件而不是Firefox插件？

Chrome占有率更高，更多人用；开发更简单，应用场景更广泛，Firefox插件只能运行在Firefox上，而Chrome除了Chrome浏览器之外，还可以运行在所有webkit内核的国产浏览器，比如360极速浏览器、360安全浏览器、搜狗浏览器、QQ浏览器等等；

开发与调试

Chrome插件没有严格的项目结构要求，只要保证本目录有一个`manifest.json`即可，也不需要专门的IDE，普通的web开发工具即可。



插件配置

```json
"browser_action":{	"default_icon": "img/icon.png",	"default_title": "这是一个示例Chrome插件",	"default_popup": "popup.html"}
```

`browser_action`图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中`default_icon`字段配置,也可以调用setIcon()方法。

修改`browser_action`的manifest中`default_title`字段，或者调用`setTitle()`方法。

所谓[content-scripts](https://developer.chrome.com/extensions/content_scripts)，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助`content-scripts`我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。

```javascript
{	// 需要直接注入页面的JS	"content_scripts": 	[		{			//"matches": ["http://*/*", "https://*/*"],			// "<all_urls>" 表示匹配所有地址			"matches": ["<all_urls>"],			// 多个JS按顺序注入			"js": ["js/jquery-1.8.3.js", "js/content-script.js"],			// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式			"css": ["css/custom.css"],			// 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle			"run_at": "document_start"		}	],}
```

Background是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。

background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置`CORS`。

鉴于background生命周期太长，长时间挂载后台可能会影响性能，所以Google又弄一个`event-pages`，在配置文件上，它与background的唯一区别就是多了一个`persistent`参数：

它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。

因为`content-script`有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用`content-script`中的代码（包括直接写`onclick`和`addEventListener`2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，

交互API

右键菜单

通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过`chrome.contextMenus`API实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里，如下：

```javascript
// manifest.json{"permissions": ["contextMenus"]}// background.jschrome.contextMenus.create({	title: "测试右键菜单",	onclick: function(){alert('您点击了右键菜单！');}});
```



### 常用chrome插件api

获取某个网站的所有cookie：

```javascript
const url = 'https://www.baidu.com';chrome.cookies.getAll({url}, cookies => {	console.log(cookies);});
```

清除某个网站的某个cookie

```javascript
const url = 'https://www.baidu.com';const cookieName = 'userName';chrome.cookies.remove({url, name: cookieName}, details => {});
```



```javascript
chrome.runtime.id：获取插件idchrome.runtime.getURL('xxx.html')：获取xxx.html在插件中的地址
```



http://blog.haoji.me/chrome-plugin-develop.html

### plasmo

plasmo是方便开发chrome浏览器的框架

新建plasmo项目

```shell
$ pnpm dls plasmo init
```

开发构建

```shell
$ pnpm dev
```

打包

```shell
$ pnpm build
```

### 发布扩展程序

注册chrome网上应用商店开发者

https://chrome.google.com/webstore/devconsole/register?hl=cn

需要5美元注册费

注册之后就可以发布新项目了

### 插件详解

https://github.com/GoogleChrome/chrome-extensions-samples

 https://oldj.net/article/2022/07/08/chrome-extension-with-react/#2-%E4%BF%AE%E6%94%B9%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE



### 权限

编译后的manifest文件示例

```json
{
  "name": "App name",
  "description": "Blank!",
  "version": "0.0.0.1",
  "manifest_version": 2,
  "icons": {
    "128": "icon.png"
  },
  "background": {
    "page": "background.html",
    "persistent": false
  },
  "browser_action": {
    "default_icon": "icon.png",
    "default_popup": "popup.html",
    "default_title": "Name"
  },
  "content_scripts": [
    {
      "all_frames": true,
      "css": ["css/main.css"],
      "js": [
        "js/jquery-3.1.0.min.js",
        "js/popup.js",
        "main.js",
        "js/dashboard.js"
      ],
      "matches": [
        "*://*.facebook.com/*/*/requests/",
        "*://*.facebook.com/*/*/requests",
        "*://*.facebook.com/*"
      ],
      "run_at": "document_end"
    }
  ],
  "content_security_policy": "script-src 'self' https://apis.google.com 'unsafe-eval'; object-src 'self'",
  "update_url": "https://clients2.google.com/service/update2/crx", 
  "oauth2": {
    "client_id": "xxxxxx-xxxxxxxxxx.apps.googleusercontent.com",
    "scopes": [
      "https://www.googleapis.com/auth/spreadsheets"
    ]
  },
  "permissions": [
    "tabs",
    "storage",
    "notifications",
    "identity",
    "*://*.herokuapp.com/*"
    ],
  "web_accessible_resources": ["*.png"]
}
```

其中的权限示例

tabs： 获取当前tab的url

storage： 存储token到本地

identity：使用谷歌登陆

notifications：通知



## vscode插件开发

VSCode是微软出的一款轻量级代码编辑器，免费而且功能强大，以功能强大、提示友好、不错的性能和颜值俘获了大量开发者的青睐，对JavaScript和NodeJS的支持非常好，自带很多功能，例如代码格式化，代码智能提示补全、Emmet插件等。

再强大的IDE那也不可能面面俱到什么功能都塞进去，那样只会导致IDE本身太臃肿。功能嘛，按需索取，所以，vscode的很多强大功能都是基于插件实现的，IDE只提供一个最基本的框子和最基本功能，由插件来丰富和扩展它的功能。

因为vscode本身都是用浏览器实现的，所以其插件不用说肯定也是基于`HTML+JS`等前端技术实现，从形式上看就是一个类似于npm包的`vsix`文件，只不过按照一些特殊规范来实现一些特殊功能，所以vscode插件开发难度不大，甚至可以说熟悉了相关API之后很容易。

vscode插件能做的事情：

1.不受限地访问磁盘：

2.编写自定义命令、快捷键、菜单：

3.自定义跳转、自动补全、悬浮提示

4.自定义设置、自定义欢迎页

5.自定义网页显示

6.自定义左侧功能面板

7.自定义颜色、图标主题

8.新增语言支持

9.Markdown增强

10.其它还有比如状态栏修改、通知提示、编辑器控制、git源代码控制、任务定义、Language Server、Debug Adapter等等。

### 官方脚手架

使用官方脚手架生成插件项目

```shell
npm install -g yo generator-code
```

cd到工作目录，运行yo code命令

安装提示安装完成，按f5运行

### 设置插件激活方式

插件在`VS Code`中默认是没有被激活的，哪什么时候才被激活呢？就是通过`activationEvents`来配置，目前支持一下8种配置：

```javascript
onLanguage:${language}onCommand:${command}onDebugworkspaceContains:${toplevelfilename}onFileSystem:${scheme}onView:${viewId}onUri*
```

如果配置了`onLanguage:javascript`，那么只要打开了JS类型的文件，插件就会被激活。

重点说一下`*`，如果配置了`*`，只要一启动vscode，插件就会被激活，为了出色的用户体验，官方不推荐这么做。看到这里相信大家知道了我们前面HelloWord里面为啥要配置`onCommand`了吧。



https://www.cnblogs.com/liuxianan/p/vscode-plugin-overview.html

