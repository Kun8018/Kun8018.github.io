---
title: 前端进阶（七）-单元测试
date: 2020-12-15 21:40:33
categories: IT
tags:
    - IT，Web,数据库
toc: true
thumbnail: https://cdn.kunkunzhang.top/babel-js.png
---

　　前端单元测试库

<!--more-->

## 前端单元测试框架

前端测试框架有

- Mocha
- Jasmine
- Jest
- Tape
- Karma

## Mocha

安装

```shell
npm install mocha --save-dev
```

使用

```javascript
const add = require("./add");
const assert = require("assert");

// describe：定义一组测试
describe("加法函数测试", function() {
    before(function() {
        // runs before all tests in this block
    });
    
    // it: 定义一个测试用例
    it("1 加 1 应该等于 2", function() {
        // assert: nodejs内置断言模块
        assert.equal(add(1, 1), 2);
    });
    
    after(function() {
        // runs after all test in this block
    });
});
```

断言库

Mocha 支持`should.js`, `chai`, `expect.js`, `better-assert`, `unexpected`等断言库

```javascript
//assert
assert.ok(add(1, 1));
assert.equal(add(1, 1), 2);
//shouldjs
(add(1, 1)).should.be.a.Number();
(add(1, 1)).should.equal(2);
//expectjs
expect(add(1, 1)).to.be.a("number");
expect(add(1, 1)).to.equal(2);
//chai支持should, expect, assert三种语法
```

`should.js`和`expect.js`相较于`assert`语义性更强，且支持类型检测，而`should.js`在语法上更加简明，同时支持链式语法`.and`。

- chai.js断言库：接口丰富，文档齐全，可以对各种接口进行断言。
- expect 库应用是非常广泛，拥有很好的链式结构和仿自然语言的方法。
- 通常写同一个断言会有几个方法，比如：expect(response).to.be(true) 和 expect(response).equal(true)。

expect和should是BDD风格的，二者使用相同的链式语言来组织断言，但不同在于他们初始化断言的方式：expect使用构造函数来创建断言对象实例，而should通过为Object.prototype新增方法来实现断言（所以should不支持IE）；expect直接指向chai.expect，而should则是chai.should()。

expect断言风格

- ok ：检查是否为真
- true：检查对象是否为真
- to.be、to：作为连接两个方法的链式方法
- not：链接一个否定的断言，如 expect(false).not.to.be(true)
- a/an：检查类型（也适用于数组类型）
- include/contain：检查数组或字符串是否包含某个元素
- below/above：检查是否大于或者小于某个限定值

assert风格是三种断言风格中唯一不支持链式调用的，Chai提供的assert风格的断言和node.js包含的assert模块非常相似。

Mocha 支持4种 hook，包括`before / after / beforeEach / afterEach`。

Mocha 默认每个测试用例执行2000ms，超出时长则报错，所以在测试代码中如果有异步操作，则需要通过`done`函数来明确测试用例结束。`done`接受`Error`参数。

Mocha 在node环境下运行时，不支持 BOM 和 DOM 接口，需要引入`jsdom`和`jsdom-global`库。

Mocha命令行基本用法：

- mocha：默认运行test子目录里面的测试脚本，不包括子文件
- mocha add.test.js：当前目录下面的该测试脚本。
- mocha file1 file2 file3 ： mocha命令后面紧跟测试脚本的路径和文件名，可以指定多个测试用例。

通配符：

- mocha spec/{my,awesome}.js
- mocha test/unit/*.js

生成格式

- mocha –reporter spec：默认为spec格式，可设置其他格式。
- mocha –recursive -R markdown > spec.md 。

网页查看

npm install –save-dev mochawesome

在gulp中运行mocha

安装gulp-mocha插件

```shell
npm install gulp-mocha --save-dev
```

gulpfile

```gulpfile
gulp.task('mocha',function() {
	return 
})
```



## Jasmine

Jasmine 是一个功能全面的测试框架，内置断言`expect`；但是有全局声明，且需要配置，相对来说使用更复杂、不够灵活。

```shell
npm install jasmine --save-dev
```

Jasmine 的语法与 Mocha 非常相似，不过断言采用内置的`expect()`。



## Jest

Jest 是一个功能全面的“零配置”测试框架，既集成了各种工具，且无需配置即可使用。

```shell
npm install --save-dev jest
```

Jest 中以`test`定义一个测试用例，且自带断言`expect`，断言库功能强大，但语法相较于`should.js`来说更复杂。

普通匹配：`toBe`, `not.toBe`

空匹配：`toBeNull`, `toBeUndefined`, `toBeDefine`, `toBeTruthy`, `toBeFalsy`

数字大小：`toBeGreaterThan`, `toBeGreaterThanOrEqual`, `toBeLessThan`, `toEqual`, `toBeCloseTo`(用于浮点数)

正则匹配：`toMatch`

数组查询：`toContain`

构造匹配：`toEqual(expect.any(constructor))`

Jest 同样有四个hook，`beforeAll/beforeEach/afterAll/afterEach`

Jest 内置对 DOM 和 BOM 接口的支持。

Jest 内置覆盖统计，为了更方便地进行相关配置，我们可以创建一个配置文件`jest.config.js`

然后将`package.json`中的命名修改一下：`"test-jest": "jest"`

jest教程：http://github.yanhaixiang.com/jest-tutorial/#%E6%B5%8B%E8%AF%95%E9%9A%BE%E7%82%B9



## Enzyme

这是一个由 Airbnb 编写的包装库，它使得测试 React 组件变得更容易。同时，我们还要为我们使用的 React 不同版本安装适配器

Enzyme的API和jQuery操作DOM一样灵活易用，因为它使用的是cheerio库来解析虚拟DOM，而cheerio的目标则是做服务器端的jQuery。Enzyme兼容大多数断言库和测试框架，如chai、mocha、jasmine等。

安装

```shell
npm i --save-dev enzyme enzyme-adapter-react-16
```

enzyme支持三种方式的渲染：

shallow：浅渲染，是对官方的Shallow Renderer的封装。将组件渲染成虚拟DOM对象，只会渲染第一层，子组件将不会被渲染出来，因而效率非常高。不需要DOM环境， 并可以使用jQuery的方式访问组件的信息；

render：静态渲染，它将React组件渲染成静态的HTML字符串，然后使用Cheerio这个库解析这段字符串，并返回一个Cheerio的实例对象，可以用来分析组件的html结构。

mount：完全渲染，它将组件渲染加载成一个真实的DOM节点，用来测试DOM API的交互和组件的生命周期，用到了jsdom来模拟浏览器环境。

enzyme中有几个比较核心的函数需要注意，如下：

simulate(event, mock)：用来模拟事件触发，event为事件名称，mock为一个event object；

instance()：返回测试组件的实例；

find(selector)：根据选择器查找节点，selector可以是CSS中的选择器，也可以是组件的构造函数，以及组件的display name等；

at(index)：返回一个渲染过的对象；

get(index)：返回一个react node，要测试它，需要重新渲染；

contains(nodeOrNodes)：当前对象是否包含参数重点 node，参数类型为react对象或对象数组；

text()：返回当前组件的文本内容；

html()： 返回当前组件的HTML代码形式；

props()：返回根组件的所有属性；

prop(key)：返回根组件的指定属性；

state()：返回根组件的状态；

setState(nextState)：设置根组件的状态；

setProps(nextProps)：设置根组件的属性；

利用enzyme渲染、操作dom，这样就可以配合Jest进行测试

```react
import React from 'react'
import { mount } from 'enzyme'
import TodoItem from '../../src/components/TodoItem.jsx'

describe('待办事项-列表项组件', () => {
  test('渲染待办事项列表项', () => {
    const todo = {id: 2, title: '复习 React Hooks 使用', completed: false}
    const wrapper = mount(
      <TodoItem todo={todo} />
    )
    const p = wrapper.find('p')
    expect(p.text()).toBe('复习 React Hooks 使用')
  })
})
```



### Sinon





## Vitest

